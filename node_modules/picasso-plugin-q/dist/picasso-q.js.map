{"version":3,"sources":["webpack://picassoQ/webpack/universalModuleDefinition","webpack://picassoQ/webpack/bootstrap","webpack://picassoQ//Users/mek/dev/qlik-oss/picasso.js/node_modules/extend/index.js","webpack://picassoQ//Users/mek/dev/qlik-oss/picasso.js/node_modules/number-format.js/lib/format.min.js","webpack://picassoQ//Users/mek/dev/qlik-oss/picasso.js/node_modules/d3-hierarchy/src/hierarchy/count.js","webpack://picassoQ//Users/mek/dev/qlik-oss/picasso.js/node_modules/d3-hierarchy/src/hierarchy/index.js","webpack://picassoQ//Users/mek/dev/qlik-oss/picasso.js/node_modules/d3-hierarchy/src/hierarchy/each.js","webpack://picassoQ//Users/mek/dev/qlik-oss/picasso.js/node_modules/d3-hierarchy/src/hierarchy/eachAfter.js","webpack://picassoQ//Users/mek/dev/qlik-oss/picasso.js/node_modules/d3-hierarchy/src/hierarchy/eachBefore.js","webpack://picassoQ//Users/mek/dev/qlik-oss/picasso.js/node_modules/d3-hierarchy/src/hierarchy/sum.js","webpack://picassoQ//Users/mek/dev/qlik-oss/picasso.js/node_modules/d3-hierarchy/src/hierarchy/sort.js","webpack://picassoQ//Users/mek/dev/qlik-oss/picasso.js/node_modules/d3-hierarchy/src/hierarchy/path.js","webpack://picassoQ//Users/mek/dev/qlik-oss/picasso.js/node_modules/d3-hierarchy/src/hierarchy/ancestors.js","webpack://picassoQ//Users/mek/dev/qlik-oss/picasso.js/node_modules/d3-hierarchy/src/hierarchy/descendants.js","webpack://picassoQ//Users/mek/dev/qlik-oss/picasso.js/node_modules/d3-hierarchy/src/hierarchy/leaves.js","webpack://picassoQ//Users/mek/dev/qlik-oss/picasso.js/node_modules/d3-hierarchy/src/hierarchy/links.js","webpack://picassoQ//Users/mek/dev/qlik-oss/picasso.js/node_modules/d3-hierarchy/src/array.js","webpack://picassoQ//Users/mek/dev/qlik-oss/picasso.js/node_modules/d3-hierarchy/src/treemap/round.js","webpack://picassoQ//Users/mek/dev/qlik-oss/picasso.js/node_modules/d3-hierarchy/src/treemap/dice.js","webpack://picassoQ//Users/mek/dev/qlik-oss/picasso.js/node_modules/d3-hierarchy/src/tree.js","webpack://picassoQ//Users/mek/dev/qlik-oss/picasso.js/node_modules/d3-hierarchy/src/treemap/slice.js","webpack://picassoQ//Users/mek/dev/qlik-oss/picasso.js/node_modules/d3-hierarchy/src/treemap/squarify.js","webpack://picassoQ//Users/mek/dev/qlik-oss/picasso.js/node_modules/d3-hierarchy/src/treemap/resquarify.js","webpack://picassoQ/./src/json-path-resolver.js","webpack://picassoQ/./src/data/augment-hierarchy.js","webpack://picassoQ/./src/data/extractor-s.js","webpack://picassoQ/./src/data/util.js","webpack://picassoQ/./src/data/extractor-t.js","webpack://picassoQ/./src/formatter/parts/qs-number-formatter.js","webpack://picassoQ/./src/formatter/numberFormat.js","webpack://picassoQ/./src/formatter/parts/qs-date-formatter.js","webpack://picassoQ/./src/formatter/timeFormat.js","webpack://picassoQ/./src/data/field.js","webpack://picassoQ/./src/formatter/index.js","webpack://picassoQ/./src/data/dataset.js","webpack://picassoQ/./src/brush/q-brush.js","webpack://picassoQ/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","hasOwn","toStr","toString","isArray","arr","Array","isPlainObject","obj","hasOwnConstructor","hasIsPrototypeOf","constructor","extend","options","src","copy","copyIsArray","clone","target","arguments","length","deep","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","undefined","a","b","isNaN","e","f","g","h","j","k","search","substring","split","reverse","join","q","u","charAt","match","toFixed","lastIndexOf","indexOf","apply","count","node","sum","children","hierarchy","data","child","childs","Node","valued","nodes","defaultChildren","pop","push","parent","depth","eachBefore","computeHeight","copyData","height","this","eachAfter","each","callback","current","next","sort","compare","path","end","start","ancestor","aNodes","ancestors","bNodes","leastCommonAncestor","splice","descendants","leaves","links","source","slice","dice","x0","y0","x1","y1","TreeNode","_","A","z","treemap_slice","phi","Math","sqrt","squarifyRatio","ratio","row","nodeValue","dx","dy","sumValue","minValue","maxValue","newRatio","minRatio","alpha","beta","rows","i0","i1","max","custom","squarify","x","resquarify","_squarify","resolve","subpath","container","carr","v","_toConsumableArray","getPathToFieldItems","field","_ref","cache","cube","attrIdx","attrDimIdx","fieldIdx","fields","attributeDimensionFields","attributeExpressionFields","concat","getAttrPath","idx","numDimz","qDimensionInfo","numMeas","qMeasureInfo","order","qEffectiveInterColumnSortOrder","min","getKPath","getTreePath","_ref2","replace","getFieldAccessor","page","deps","wrappedFields","attrDims","map","instance","attrExps","qArea","qLeft","qWidth","Function","datumExtract","propCfg","cell","datum","label","String","extract","config","dataset","util","dataItems","forEach","cfg","raw","sourceKey","_typeof","_util$normalizeConfig","normalizeConfig","props","main","propsArr","keys","track","trackBy","trackType","tracker","trackedItems","items","qDataPages","fn","qMatrix","rowIdx","qTop","mainCell","extend_default","qRow","ret","filter","prop","pp","fidx","targetProp","propCell","propCellFn","cellToValue","fieldValues","fieldLabels","itemData","extractor_s_toConsumableArray","collect","treeAccessor","sourceDepth","targetDepth","arrIndexAtTargetDepth","steps","util_toConsumableArray","valueOf","flattenTree","DIM_RX","M_RX","ATTR_EXPR_RX","ATTR_DIM_RX","getFieldDepth","isFieldDimension","pseudoMeasureIndex","measureIdx","remainder","treeOrder","test","exec","qMode","fieldDepth","extractor_t_getFieldAccessor","sourceDepthObject","targetDepthObject","valueFn","attrFn","nodeFn","qValues","qAttrDims","qAttrExps","extractor_t_extract","_ret","rootPath","childNodes","extractor_t_typeof","tree","itemDepthObject","_getFieldAccessor","pCfg","isSame","depthObject","accessors","accessor","valueAccessor","attrAccessor","mapped","_loop","item","extractor_t_datumExtract","coll","type","reduce","extractor_t_toConsumableArray","escapeRegExp","str","SIprefixes","3","6","9","12","15","18","21","24","-3","-6","-9","-12","-15","-18","-21","-24","percentage","radix","oct","dec","hex","bin","rom","functional","prec","formatRadix","fradix","pattern","decimal","toUpperCase","formatFunctional","temp","Number","floor","nThousands","numeral","toLowerCase","formatRoman","toExponential","qs_number_formatter_escape","flags","justStr","RegExp","preparePattern","parts","lastPart","numericPattern","prefix","postfix","groupTemp","decTemp","regex","abbreviate","thousand","createRegExp","substr","matchPrecisionResult","splitPattern","maxPrecision","numericRegex","qs_number_formatter_NumberFormatter","NumberFormatter","localeInfo","_classCallCheck","thousandDelimiter","decimalDelimiter","patternSeparator","abbreviations","listSeparator","qNumericalAbbreviation","abbreviation","abbreviationTuple","getAbbreviations","prepare","subtype","formatValue","prep","_prepared","positive","isFunctional","negative","zero","exponent","absValue","num","decimalPartPattern","abbr","sciValue","original","lowerAbbreviation","suggestedAbbrExponent","abbrArray","parseInt","upperAbbreviation","pow","abs","round","wholePart","wholePartPattern","format_min_default","nDecimals","nZeroes","decimalPart","toPrecision","ceil","log","formatter","qType","qformat","_len","args","_key","_construct","numberFormatFactory","format","DAYS","DAYS_ABBR","MONTHS","MONTHS_ABBR","pad","getRemainder","parseInterval","days","date","units","ms","parseIntervalDays","w","Date","getTime","getDay","someT","getHours","year","month","day","qs_date_formatter_DateFormatter","DateFormatter","qtype","qs_date_formatter_classCallCheck","_patternMap","info","qCalendarStrings","qLongDayNames","qDayNames","qLongMonthNames","qMonthNames","locale_days","locale_days_abbr","locale_months","locale_months_abbr","patternMap","TYPES","TIME","qTimeFmt","_defineProperty","DATE","qDateFmt","DATE_TIME","qTimestampFmt","parsedDate","hasTwelveFlag","twelveFormat","getFullYear","getMonth","getDate","getMinutes","getSeconds","getMilliseconds","parseDate","masks","inst","Y+|y+","Y","YY","YYY","def","M+","M","MM","MMM","W+|w+","W","WW","WWW","D+|d+","D","h+|H+","m+","s+|S+","f+|F+","t{1,2}|T{1,2}","getMasks","masksArr","mask","dateTimeRegex","submask","dateFormatFactory","qs_date_formatter_construct","AUTO","INTEGER","NUMBER","FIXED_TO","MONEY","INTERVAL","timeFormat_formatter","QlikTimeToDate","locale","li","nqt","qField","values","meta","id","fieldExtractor","qElemNo","qValue","qNumFormat","qFmt","qThousandSep","qDecimalSep","isAuto","qIsAutoFormat","qThou","qDec","createFromMetaInfo","title","qFallbackTitle","qMin","qMax","qText","tags","qTags","qSubNodes","propDefs","_deps$normalizeConfig","currentField","isRoot","currentItemsPath","fieldPath","isDescendant","pathToNode","originalData","expando","currentOriginal","it","augment","createFields","parentKey","opts","fieldKey","qNum","measures","_cache$wrappedFields","_cache$wrappedFields2","_ref$config","allFields","Error","pages","query","findField","extractionConfig","extractor","hierarchyConfig","_cache","qNodesOnDim","qStackedDataPages","qTreeDataPages","ectractor","dimAcc","qElemNumber","measAcc","dataset_toConsumableArray","traverse","LAYOUT_TO_PROP","q_brush_DIM_RX","q_brush_M_RX","q_brush_ATTR_DIM_RX","q_brush_ATTR_EXPR_RX","HC_RX","TD_RX","SHORTEN_HC","SHORTEN_TD","qBrush","brush","layout","byCells","primarySource","selections","methods","isActive","hasValues","brushes","dimensionIdx","pathToCube","shortenizer","shortenPath","attrCol","offset","hc","dim","qAttrExprInfo","meas","_slicedToArray","extractFieldFromId","ranges","multiRangeSelectTreeDataValues","range","qMeasureIx","qDimensionIx","qRange","qMinInclEq","qMaxInclEq","rangeSelectHyperCubeValues","selectHyperCubeContinuousRange","qDimIx","selectHyperCubeCells","cols","params","method","initialize","picasso","qBrushHelper"],"mappings":"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","file":"picasso-q.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"picassoQ\"] = factory();\n\telse\n\t\troot[\"picassoQ\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = target[name];\n\t\t\t\tcopy = options[name];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n","/*! javascript-number-formatter - v1.1.11 - http://mottie.github.com/javascript-number-formatter/ *  ecava */\n!function(a,b){\"function\"==typeof define&&define.amd?define([],b):\"object\"==typeof module?module.exports=b():a.format=b()}(this,function(){return function(a,b){\"use strict\";if(!a||isNaN(+b))return b;var c,d,e,f,g,h,i,j,k,l,m=a.length,n=a.search(/[0-9\\-\\+#]/),o=n>0?a.substring(0,n):\"\",p=a.split(\"\").reverse().join(\"\"),q=p.search(/[0-9\\-\\+#]/),r=m-q,s=a.substring(r,r+1),t=r+(\".\"===s||\",\"===s?1:0),u=q>0?a.substring(t,m):\"\";if(a=a.substring(n,t),b=\"-\"===a.charAt(0)?-b:+b,c=b<0?b=-b:0,d=a.match(/[^\\d\\-\\+#]/g),e=d&&d[d.length-1]||\".\",f=d&&d[1]&&d[0]||\",\",a=a.split(e),b=b.toFixed(a[1]&&a[1].length),b=+b+\"\",h=a[1]&&a[1].lastIndexOf(\"0\"),j=b.split(\".\"),(!j[1]||j[1]&&j[1].length<=h)&&(b=(+b).toFixed(h+1)),k=a[0].split(f),a[0]=k.join(\"\"),g=a[0]&&a[0].indexOf(\"0\"),g>-1)for(;j[0].length<a[0].length-g;)j[0]=\"0\"+j[0];else 0===+j[0]&&(j[0]=\"\");if(b=b.split(\".\"),b[0]=j[0],i=k[1]&&k[k.length-1].length){for(l=b[0],p=\"\",r=l.length%i,m=l.length,t=0;t<m;t++)p+=l.charAt(t),!((t-r+1)%i)&&t<m-i&&(p+=f);b[0]=p}return b[1]=a[1]&&b[1]?e+b[1]:\"\",d=b.join(\"\"),\"0\"!==d&&\"\"!==d||(c=!1),o+((c?\"-\":\"\")+d)+u}});","function count(node) {\n  var sum = 0,\n      children = node.children,\n      i = children && children.length;\n  if (!i) sum = 1;\n  else while (--i >= 0) sum += children[i].value;\n  node.value = sum;\n}\n\nexport default function() {\n  return this.eachAfter(count);\n}\n","import node_count from \"./count\";\nimport node_each from \"./each\";\nimport node_eachBefore from \"./eachBefore\";\nimport node_eachAfter from \"./eachAfter\";\nimport node_sum from \"./sum\";\nimport node_sort from \"./sort\";\nimport node_path from \"./path\";\nimport node_ancestors from \"./ancestors\";\nimport node_descendants from \"./descendants\";\nimport node_leaves from \"./leaves\";\nimport node_links from \"./links\";\n\nexport default function hierarchy(data, children) {\n  var root = new Node(data),\n      valued = +data.value && (root.value = data.value),\n      node,\n      nodes = [root],\n      child,\n      childs,\n      i,\n      n;\n\n  if (children == null) children = defaultChildren;\n\n  while (node = nodes.pop()) {\n    if (valued) node.value = +node.data.value;\n    if ((childs = children(node.data)) && (n = childs.length)) {\n      node.children = new Array(n);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new Node(childs[i]));\n        child.parent = node;\n        child.depth = node.depth + 1;\n      }\n    }\n  }\n\n  return root.eachBefore(computeHeight);\n}\n\nfunction node_copy() {\n  return hierarchy(this).eachBefore(copyData);\n}\n\nfunction defaultChildren(d) {\n  return d.children;\n}\n\nfunction copyData(node) {\n  node.data = node.data.data;\n}\n\nexport function computeHeight(node) {\n  var height = 0;\n  do node.height = height;\n  while ((node = node.parent) && (node.height < ++height));\n}\n\nexport function Node(data) {\n  this.data = data;\n  this.depth =\n  this.height = 0;\n  this.parent = null;\n}\n\nNode.prototype = hierarchy.prototype = {\n  constructor: Node,\n  count: node_count,\n  each: node_each,\n  eachAfter: node_eachAfter,\n  eachBefore: node_eachBefore,\n  sum: node_sum,\n  sort: node_sort,\n  path: node_path,\n  ancestors: node_ancestors,\n  descendants: node_descendants,\n  leaves: node_leaves,\n  links: node_links,\n  copy: node_copy\n};\n","export default function(callback) {\n  var node = this, current, next = [node], children, i, n;\n  do {\n    current = next.reverse(), next = [];\n    while (node = current.pop()) {\n      callback(node), children = node.children;\n      if (children) for (i = 0, n = children.length; i < n; ++i) {\n        next.push(children[i]);\n      }\n    }\n  } while (next.length);\n  return this;\n}\n","export default function(callback) {\n  var node = this, nodes = [node], next = [], children, i, n;\n  while (node = nodes.pop()) {\n    next.push(node), children = node.children;\n    if (children) for (i = 0, n = children.length; i < n; ++i) {\n      nodes.push(children[i]);\n    }\n  }\n  while (node = next.pop()) {\n    callback(node);\n  }\n  return this;\n}\n","export default function(callback) {\n  var node = this, nodes = [node], children, i;\n  while (node = nodes.pop()) {\n    callback(node), children = node.children;\n    if (children) for (i = children.length - 1; i >= 0; --i) {\n      nodes.push(children[i]);\n    }\n  }\n  return this;\n}\n","export default function(value) {\n  return this.eachAfter(function(node) {\n    var sum = +value(node.data) || 0,\n        children = node.children,\n        i = children && children.length;\n    while (--i >= 0) sum += children[i].value;\n    node.value = sum;\n  });\n}\n","export default function(compare) {\n  return this.eachBefore(function(node) {\n    if (node.children) {\n      node.children.sort(compare);\n    }\n  });\n}\n","export default function(end) {\n  var start = this,\n      ancestor = leastCommonAncestor(start, end),\n      nodes = [start];\n  while (start !== ancestor) {\n    start = start.parent;\n    nodes.push(start);\n  }\n  var k = nodes.length;\n  while (end !== ancestor) {\n    nodes.splice(k, 0, end);\n    end = end.parent;\n  }\n  return nodes;\n}\n\nfunction leastCommonAncestor(a, b) {\n  if (a === b) return a;\n  var aNodes = a.ancestors(),\n      bNodes = b.ancestors(),\n      c = null;\n  a = aNodes.pop();\n  b = bNodes.pop();\n  while (a === b) {\n    c = a;\n    a = aNodes.pop();\n    b = bNodes.pop();\n  }\n  return c;\n}\n","export default function() {\n  var node = this, nodes = [node];\n  while (node = node.parent) {\n    nodes.push(node);\n  }\n  return nodes;\n}\n","export default function() {\n  var nodes = [];\n  this.each(function(node) {\n    nodes.push(node);\n  });\n  return nodes;\n}\n","export default function() {\n  var leaves = [];\n  this.eachBefore(function(node) {\n    if (!node.children) {\n      leaves.push(node);\n    }\n  });\n  return leaves;\n}\n","export default function() {\n  var root = this, links = [];\n  root.each(function(node) {\n    if (node !== root) { // Dont include the roots parent, if any.\n      links.push({source: node.parent, target: node});\n    }\n  });\n  return links;\n}\n","export var slice = Array.prototype.slice;\n\nexport function shuffle(array) {\n  var m = array.length,\n      t,\n      i;\n\n  while (m) {\n    i = Math.random() * m-- | 0;\n    t = array[m];\n    array[m] = array[i];\n    array[i] = t;\n  }\n\n  return array;\n}\n","export default function(node) {\n  node.x0 = Math.round(node.x0);\n  node.y0 = Math.round(node.y0);\n  node.x1 = Math.round(node.x1);\n  node.y1 = Math.round(node.y1);\n}\n","export default function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      node,\n      i = -1,\n      n = nodes.length,\n      k = parent.value && (x1 - x0) / parent.value;\n\n  while (++i < n) {\n    node = nodes[i], node.y0 = y0, node.y1 = y1;\n    node.x0 = x0, node.x1 = x0 += node.value * k;\n  }\n}\n","import {Node} from \"./hierarchy/index\";\n\nfunction defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\n\n// function radialSeparation(a, b) {\n//   return (a.parent === b.parent ? 1 : 2) / a.depth;\n// }\n\n// This function is used to traverse the left contour of a subtree (or\n// subforest). It returns the successor of v on this contour. This successor is\n// either given by the leftmost child of v or by the thread of v. The function\n// returns null if and only if v is on the highest level of its subtree.\nfunction nextLeft(v) {\n  var children = v.children;\n  return children ? children[0] : v.t;\n}\n\n// This function works analogously to nextLeft.\nfunction nextRight(v) {\n  var children = v.children;\n  return children ? children[children.length - 1] : v.t;\n}\n\n// Shifts the current subtree rooted at w+. This is done by increasing\n// prelim(w+) and mod(w+) by shift.\nfunction moveSubtree(wm, wp, shift) {\n  var change = shift / (wp.i - wm.i);\n  wp.c -= change;\n  wp.s += shift;\n  wm.c += change;\n  wp.z += shift;\n  wp.m += shift;\n}\n\n// All other shifts, applied to the smaller subtrees between w- and w+, are\n// performed by this function. To prepare the shifts, we have to adjust\n// change(w+), shift(w+), and change(w-).\nfunction executeShifts(v) {\n  var shift = 0,\n      change = 0,\n      children = v.children,\n      i = children.length,\n      w;\n  while (--i >= 0) {\n    w = children[i];\n    w.z += shift;\n    w.m += shift;\n    shift += w.s + (change += w.c);\n  }\n}\n\n// If vi-s ancestor is a sibling of v, returns vi-s ancestor. Otherwise,\n// returns the specified (default) ancestor.\nfunction nextAncestor(vim, v, ancestor) {\n  return vim.a.parent === v.parent ? vim.a : ancestor;\n}\n\nfunction TreeNode(node, i) {\n  this._ = node;\n  this.parent = null;\n  this.children = null;\n  this.A = null; // default ancestor\n  this.a = this; // ancestor\n  this.z = 0; // prelim\n  this.m = 0; // mod\n  this.c = 0; // change\n  this.s = 0; // shift\n  this.t = null; // thread\n  this.i = i; // number\n}\n\nTreeNode.prototype = Object.create(Node.prototype);\n\nfunction treeRoot(root) {\n  var tree = new TreeNode(root, 0),\n      node,\n      nodes = [tree],\n      child,\n      children,\n      i,\n      n;\n\n  while (node = nodes.pop()) {\n    if (children = node._.children) {\n      node.children = new Array(n = children.length);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new TreeNode(children[i], i));\n        child.parent = node;\n      }\n    }\n  }\n\n  (tree.parent = new TreeNode(null, 0)).children = [tree];\n  return tree;\n}\n\n// Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\nexport default function() {\n  var separation = defaultSeparation,\n      dx = 1,\n      dy = 1,\n      nodeSize = null;\n\n  function tree(root) {\n    var t = treeRoot(root);\n\n    // Compute the layout using Buchheim et al.s algorithm.\n    t.eachAfter(firstWalk), t.parent.m = -t.z;\n    t.eachBefore(secondWalk);\n\n    // If a fixed node size is specified, scale x and y.\n    if (nodeSize) root.eachBefore(sizeNode);\n\n    // If a fixed tree size is specified, scale x and y based on the extent.\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    else {\n      var left = root,\n          right = root,\n          bottom = root;\n      root.eachBefore(function(node) {\n        if (node.x < left.x) left = node;\n        if (node.x > right.x) right = node;\n        if (node.depth > bottom.depth) bottom = node;\n      });\n      var s = left === right ? 1 : separation(left, right) / 2,\n          tx = s - left.x,\n          kx = dx / (right.x + s + tx),\n          ky = dy / (bottom.depth || 1);\n      root.eachBefore(function(node) {\n        node.x = (node.x + tx) * kx;\n        node.y = node.depth * ky;\n      });\n    }\n\n    return root;\n  }\n\n  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is\n  // applied recursively to the children of v, as well as the function\n  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the\n  // node v is placed to the midpoint of its outermost children.\n  function firstWalk(v) {\n    var children = v.children,\n        siblings = v.parent.children,\n        w = v.i ? siblings[v.i - 1] : null;\n    if (children) {\n      executeShifts(v);\n      var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n      if (w) {\n        v.z = w.z + separation(v._, w._);\n        v.m = v.z - midpoint;\n      } else {\n        v.z = midpoint;\n      }\n    } else if (w) {\n      v.z = w.z + separation(v._, w._);\n    }\n    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n  }\n\n  // Computes all real x-coordinates by summing up the modifiers recursively.\n  function secondWalk(v) {\n    v._.x = v.z + v.parent.m;\n    v.m += v.parent.m;\n  }\n\n  // The core of the algorithm. Here, a new subtree is combined with the\n  // previous subtrees. Threads are used to traverse the inside and outside\n  // contours of the left and right subtree up to the highest common level. The\n  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the\n  // superscript o means outside and i means inside, the subscript - means left\n  // subtree and + means right subtree. For summing up the modifiers along the\n  // contour, we use respective variables si+, si-, so-, and so+. Whenever two\n  // nodes of the inside contours conflict, we compute the left one of the\n  // greatest uncommon ancestors using the function ANCESTOR and call MOVE\n  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n  // Finally, we add a new thread (if necessary).\n  function apportion(v, w, ancestor) {\n    if (w) {\n      var vip = v,\n          vop = v,\n          vim = w,\n          vom = vip.parent.children[0],\n          sip = vip.m,\n          sop = vop.m,\n          sim = vim.m,\n          som = vom.m,\n          shift;\n      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n        vom = nextLeft(vom);\n        vop = nextRight(vop);\n        vop.a = v;\n        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n        if (shift > 0) {\n          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\n          sip += shift;\n          sop += shift;\n        }\n        sim += vim.m;\n        sip += vip.m;\n        som += vom.m;\n        sop += vop.m;\n      }\n      if (vim && !nextRight(vop)) {\n        vop.t = vim;\n        vop.m += sim - sop;\n      }\n      if (vip && !nextLeft(vom)) {\n        vom.t = vip;\n        vom.m += sip - som;\n        ancestor = v;\n      }\n    }\n    return ancestor;\n  }\n\n  function sizeNode(node) {\n    node.x *= dx;\n    node.y = node.depth * dy;\n  }\n\n  tree.separation = function(x) {\n    return arguments.length ? (separation = x, tree) : separation;\n  };\n\n  tree.size = function(x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);\n  };\n\n  tree.nodeSize = function(x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);\n  };\n\n  return tree;\n}\n","export default function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      node,\n      i = -1,\n      n = nodes.length,\n      k = parent.value && (y1 - y0) / parent.value;\n\n  while (++i < n) {\n    node = nodes[i], node.x0 = x0, node.x1 = x1;\n    node.y0 = y0, node.y1 = y0 += node.value * k;\n  }\n}\n","import treemapDice from \"./dice\";\nimport treemapSlice from \"./slice\";\n\nexport var phi = (1 + Math.sqrt(5)) / 2;\n\nexport function squarifyRatio(ratio, parent, x0, y0, x1, y1) {\n  var rows = [],\n      nodes = parent.children,\n      row,\n      nodeValue,\n      i0 = 0,\n      i1 = 0,\n      n = nodes.length,\n      dx, dy,\n      value = parent.value,\n      sumValue,\n      minValue,\n      maxValue,\n      newRatio,\n      minRatio,\n      alpha,\n      beta;\n\n  while (i0 < n) {\n    dx = x1 - x0, dy = y1 - y0;\n\n    // Find the next non-empty node.\n    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);\n    minValue = maxValue = sumValue;\n    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n    beta = sumValue * sumValue * alpha;\n    minRatio = Math.max(maxValue / beta, beta / minValue);\n\n    // Keep adding nodes while the aspect ratio maintains or improves.\n    for (; i1 < n; ++i1) {\n      sumValue += nodeValue = nodes[i1].value;\n      if (nodeValue < minValue) minValue = nodeValue;\n      if (nodeValue > maxValue) maxValue = nodeValue;\n      beta = sumValue * sumValue * alpha;\n      newRatio = Math.max(maxValue / beta, beta / minValue);\n      if (newRatio > minRatio) { sumValue -= nodeValue; break; }\n      minRatio = newRatio;\n    }\n\n    // Position and record the row orientation.\n    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});\n    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);\n    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);\n    value -= sumValue, i0 = i1;\n  }\n\n  return rows;\n}\n\nexport default (function custom(ratio) {\n\n  function squarify(parent, x0, y0, x1, y1) {\n    squarifyRatio(ratio, parent, x0, y0, x1, y1);\n  }\n\n  squarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return squarify;\n})(phi);\n","import treemapDice from \"./dice\";\nimport treemapSlice from \"./slice\";\nimport {phi, squarifyRatio} from \"./squarify\";\n\nexport default (function custom(ratio) {\n\n  function resquarify(parent, x0, y0, x1, y1) {\n    if ((rows = parent._squarify) && (rows.ratio === ratio)) {\n      var rows,\n          row,\n          nodes,\n          i,\n          j = -1,\n          n,\n          m = rows.length,\n          value = parent.value;\n\n      while (++j < m) {\n        row = rows[j], nodes = row.children;\n        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;\n        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);\n        else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);\n        value -= row.value;\n      }\n    } else {\n      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);\n      rows.ratio = ratio;\n    }\n  }\n\n  resquarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return resquarify;\n})(phi);\n","/**\n * Resolves the value at the given JSON path\n * @private\n * @param  {String} path [description]\n * @param  {Object} obj  [description]\n * @return {Object}      [description]\n *\n * @example\n * let path = \"/path/to/paradise\";\n * let obj = {\n *   path: {\n *     to: { paradise: \"heaven\"},\n *     from: {...}\n *   }\n * };\n * resolve( path, obj ); // \"heaven\"\n */\nexport default function resolve(path, obj) {\n  if (path.charAt(0) === '/') {\n    path = path.substring(1);\n  }\n  const arr = path.split('/');\n  let subpath;\n  let container = obj;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === '*' && Array.isArray(container)) {\n      const carr = [];\n      subpath = arr.slice(i + 1).join('/');\n      for (let c = 0; c < container.length; c++) {\n        let v = resolve(subpath, container[c]);\n        // v.forEach(_ => _._parent = container[c]);\n        if (Array.isArray(v)) {\n          carr.push(...v);\n        } else {\n          carr.push(v);\n        }\n      }\n      return carr;\n      // return container.map(v => resolve(arr.slice(i + 1).join('/'), v));\n    } else if (!arr[i] && Array.isArray(container)) {\n      const carr = new Array(container.length);\n      subpath = arr.slice(i + 1).join('/');\n      for (let c = 0; c < container.length; c++) {\n        carr[c] = resolve(subpath, container[c]);\n      }\n      return carr;\n      // return container.map(v => resolve(arr.slice(i + 1).join('/'), v));\n    } else if (arr[i] in container) {\n      container = container[arr[i]];\n    }\n  }\n\n  return container;\n}\n","import { hierarchy } from 'd3-hierarchy';\n\nimport picker from '../json-path-resolver';\n\nfunction getKPath(fieldIdx, cube) {\n  let idx = fieldIdx;\n  const numDimz = cube.qDimensionInfo.length;\n  const numMeas = cube.qMeasureInfo.length;\n  const order = cube.qEffectiveInterColumnSortOrder;\n  if (idx < numDimz && order) {\n    idx = order.indexOf(idx);\n  } else if (idx >= numDimz && order && numMeas > 1 && order.indexOf(-1) !== -1) {\n    idx = order.indexOf(-1);\n  }\n  let s = '/qData/*/qSubNodes';\n  const depth = Math.max(0, Math.min(idx, numDimz));\n  let i = 0;\n  for (; i < depth; i++) { // traverse down to specified depth\n    s += '/*/qSubNodes';\n  }\n  if (fieldIdx >= numDimz) {\n    // if the depth is a pseudo level, pick the given pseudo dimension, and then traverse down to leaf level (value nodes)\n    if (numMeas > 1) {\n      s += `/${fieldIdx - numDimz}/qSubNodes`; // pick pseudo dimension (measure)\n      ++i;\n      // traverse to value nodes\n      for (; i <= numDimz; i++) {\n        s += '/*/qSubNodes';\n      }\n    } else {\n      s += `/${fieldIdx - numDimz}`;\n    }\n  }\n  return s;\n}\n\nfunction getAttrPath(s, attrIdx, attrDimIdx) {\n  if (typeof attrIdx === 'number') {\n    return `${s}/*/qAttrExps/qValues/${attrIdx}`;\n  }\n  if (typeof attrDimIdx === 'number') {\n    return `${s}/*/qAttrDims/qValues/${attrDimIdx}`;\n  }\n  return s;\n}\n\n\nfunction getPathToFieldItems(field, {\n  cache,\n  cube\n}) {\n  if (!field) {\n    return '';\n  }\n  let fieldIdx = cache.fields.indexOf(field);\n  let attrIdx;\n  let attrDimIdx;\n  if (fieldIdx === -1) {\n    for (let i = 0; i < cache.attributeDimensionFields.length; i++) {\n      attrDimIdx = cache.attributeDimensionFields[i] ? cache.attributeDimensionFields[i].indexOf(field) : -1;\n      if (attrDimIdx !== -1) {\n        fieldIdx = i;\n        break;\n      }\n    }\n  }\n  if (fieldIdx === -1) {\n    for (let i = 0; i < cache.attributeExpressionFields.length; i++) {\n      attrIdx = cache.attributeExpressionFields[i] ? cache.attributeExpressionFields[i].indexOf(field) : -1;\n      if (attrIdx !== -1) {\n        fieldIdx = i;\n        break;\n      }\n    }\n  }\n  return getAttrPath(getKPath(fieldIdx, cube), attrIdx >= 0 ? attrIdx : undefined, attrDimIdx >= 0 ? attrDimIdx : undefined);\n}\n\nfunction getTreePath(field, { cache, cube }) {\n  const s1 = getPathToFieldItems(field, { cache, cube });\n  const s2 = s1.replace(/qSubNodes/g, 'children');\n  const s3 = s2.replace(/children$/g, 'children/*');\n  return s3.replace(/qData\\/\\*/, '');\n}\n\nexport default function augment(config, dataset, cache, deps) {\n  const rootPath = '/qStackedDataPages/*/qData';\n  const cube = dataset.raw();\n\n  const root = picker(rootPath, cube);\n  if (!root || !root[0]) {\n    return null;\n  }\n\n  const h = hierarchy(root[0], config.children || (node => node.qSubNodes));\n\n  const height = h.height;\n  const propDefs = [];\n  for (let i = 0; i <= height; i++) {\n    const { props, main } = deps.normalizeConfig(config, dataset);\n    const propsArr = Object.keys(props);\n    propDefs[i] = { propsArr, props, main };\n    let currentField = null;\n    const isRoot = i === 0;\n    if (i > 0) {\n      let idx = cube.qEffectiveInterColumnSortOrder[i - 1];\n      // if (idx === -1) { // pseudo\n      //   let childIdx = node.parent.children.indexOf(node);\n      //   idx = cube.qDimensionInfo.length + childIdx; // measure field\n      // }\n      if (i > cube.qEffectiveInterColumnSortOrder.length) {\n        idx = cube.qDimensionInfo.length;\n      }\n\n      currentField = cache.fields[idx];\n    }\n    const currentItemsPath = currentField ? getTreePath(currentField, { cube, cache }) : rootPath;\n\n    propsArr.forEach((prop) => {\n      const pCfg = props[prop];\n      const arr = pCfg.fields ? pCfg.fields : [pCfg];\n      arr.forEach((p) => {\n        if (p.field) {\n          const fieldPath = getTreePath(p.field, { cube, cache });\n          if (fieldPath === currentItemsPath) {\n            p.isSame = true;\n          } else if (isRoot) {\n            p.isDescendant = true;\n            p.path = `${fieldPath}/data`;\n          } else {\n            const isDescendant = fieldPath.match(/\\//g).length > currentItemsPath.match(/\\//g).length;\n            let pathToNode = '';\n            if (isDescendant) {\n              pathToNode = `${fieldPath.replace(currentItemsPath, '').replace(/^\\/\\*/, '')}/data`;\n            } else {\n              pathToNode = Math.ceil((currentItemsPath.match(/\\//g).length - fieldPath.match(/\\//g).length) / 2);\n            }\n            p.isDescendant = isDescendant;\n            p.path = pathToNode;\n          }\n        }\n      });\n    });\n  }\n\n  const originalData = [];\n  let expando = 0;\n  h.each((node) => {\n    const currentOriginal = originalData[expando++] = node.data;\n    const propsArr = propDefs[node.depth].propsArr;\n    const props = propDefs[node.depth].props;\n    const main = propDefs[node.depth].main;\n\n    node.data = {\n      value: typeof main.value === 'function' ? main.value(currentOriginal) : currentOriginal\n    };\n    propsArr.forEach((prop) => {\n      const pCfg = props[prop];\n      const arr = pCfg.fields ? pCfg.fields : [pCfg];\n      let coll;\n      if (pCfg.fields) {\n        coll = [];\n      }\n      arr.forEach((p) => {\n        let fn = v => v;\n        let value;\n        if (p.type === 'primitive') {\n          value = p.value;\n        } else {\n          if (typeof p.value === 'function') {\n            fn = (v, n) => p.value(v, n);\n          }\n          if (!p.field) {\n            value = currentOriginal;\n          } else if (p.isSame) {\n            value = currentOriginal;\n          } else if (p.isDescendant) {\n            value = picker(p.path, node);\n            if (Array.isArray(value)) {\n              value = value.map(fn);\n              fn = p.reduce || (v => v.join(', '));\n            }\n          } else if (p.path) { // ancestor\n            const num = p.path || 0;\n            let it = node;\n            for (let i = 0; i < num; i++) {\n              it = it.parent;\n            }\n            value = it.data.value;\n          }\n        }\n        if (pCfg.fields) {\n          coll.push(fn(value, node));\n        } else {\n          node.data[prop] = {\n            value: fn(value, node)\n          };\n          if (p.source) {\n            node.data[prop].source = { field: p.source };\n          }\n        }\n      });\n\n      // reduce row if multiple fields\n      if (coll) {\n        node.data[prop] = {\n          value: typeof pCfg.value === 'function' ? pCfg.value(coll, node) : coll\n        };\n      }\n    });\n  });\n\n  return h;\n}\n","import extend from 'extend';\n\nexport function getFieldAccessor(field, page, deps) {\n  if (!field) {\n    return -1;\n  }\n  const cache = deps.cache;\n  let fieldIdx = cache.fields.indexOf(field);\n  let attrIdx = -1;\n  let attrDimIdx = -1;\n  if (fieldIdx === -1) {\n    for (let i = 0; i < cache.wrappedFields.length; i++) {\n      attrDimIdx = cache.wrappedFields[i].attrDims.map(v => v.instance).indexOf(field);\n      attrIdx = cache.wrappedFields[i].attrExps.map(v => v.instance).indexOf(field);\n      if (attrDimIdx !== -1 || attrIdx !== -1) {\n        fieldIdx = i;\n        break;\n      }\n    }\n  }\n\n  fieldIdx -= page.qArea.qLeft;\n  if (fieldIdx < 0 || fieldIdx >= page.qArea.qWidth) {\n    // throw new Error('Field out of range');\n    return -1;\n  }\n\n  let path = `row[${fieldIdx}]`;\n\n  if (attrDimIdx >= 0) {\n    return Function('row', `return ${path}.qAttrDims.qValues[${attrDimIdx}];`); // eslint-disable-line no-new-func\n  } else if (attrIdx >= 0) {\n    return Function('row', `return ${path}.qAttrExps.qValues[${attrIdx}];`); // eslint-disable-line no-new-func\n  }\n\n  return Function('row', `return ${path};`); // eslint-disable-line no-new-func\n}\n\n// TODO - handle 'other' value\n// const specialTextValues = {\n//   '-3': (meta) => {\n//     if ('othersLabel' in meta) {\n//       return meta.othersLabel;\n//     }\n//     return '';\n//   }\n// };\n\nfunction datumExtract(propCfg, cell, {\n  key\n}) {\n  const datum = {\n    value: typeof propCfg.value === 'function' ? propCfg.value(cell) : typeof propCfg.value !== 'undefined' ? propCfg.value : cell // eslint-disable-line no-nested-ternary\n  };\n\n  datum.label = typeof propCfg.label === 'function' ? propCfg.label(cell) : typeof propCfg.label !== 'undefined' ? String(propCfg.label) : String(datum.value); // eslint-disable-line no-nested-ternary\n\n  if (propCfg.field) {\n    datum.source = {\n      key,\n      field: propCfg.field.key()\n    };\n  }\n\n  return datum;\n}\n\nfunction cellToValue({\n  cache,\n  f,\n  mainCell,\n  p,\n  prop,\n  page,\n  rowIdx,\n  row,\n  sourceKey,\n  target,\n  targetProp\n}) {\n  let propCell = mainCell;\n  if (p.field && p.field !== f) {\n    const propCellFn = getFieldAccessor(p.field, page, { cache });\n    if (propCellFn === -1) {\n      return;\n    }\n    propCell = extend({ qRow: rowIdx }, propCellFn(row));\n  }\n  target[targetProp] = datumExtract(p, propCell, { key: sourceKey }, prop);\n}\n\nexport default function extract(config, dataset, cache, util) {\n  const cfgs = Array.isArray(config) ? config : [config];\n  let dataItems = [];\n  cfgs.forEach((cfg) => {\n    if (typeof cfg.field !== 'undefined') {\n      const cube = dataset.raw();\n      const sourceKey = dataset.key();\n      const f = typeof cfg.field === 'object' ? cfg.field : dataset.field(cfg.field);\n      const { props, main } = util.normalizeConfig(cfg, dataset);\n      const propsArr = Object.keys(props);\n\n      const track = !!cfg.trackBy;\n      const trackType = typeof cfg.trackBy;\n      const tracker = {};\n      const trackedItems = [];\n      const items = [];\n\n      cube.qDataPages.forEach((page) => {\n        const fn = getFieldAccessor(f, page, { cache });\n        if (fn === -1) {\n          return;\n        }\n        page.qMatrix.forEach((row, i) => {\n          const rowIdx = page.qArea.qTop + i;\n          const mainCell = extend({ qRow: rowIdx }, fn(row));\n          const ret = datumExtract(main, mainCell, { key: sourceKey });\n          const exclude = main.filter && !main.filter(mainCell);\n          if (exclude) {\n            return;\n          }\n\n          // loop through all props that need to be mapped and\n          // assign 'value' and 'source' to each property\n          propsArr.forEach((prop) => {\n            const p = props[prop];\n            let arr = p.fields || [p];\n\n            if (p.fields) {\n              ret[prop] = [];\n            }\n            arr.forEach((pp, fidx) => {\n              cellToValue({\n                cache,\n                f,\n                mainCell,\n                p: pp,\n                prop,\n                props,\n                page,\n                rowIdx,\n                row,\n                sourceKey,\n                target: p.fields ? ret[prop] : ret,\n                targetProp: p.fields ? fidx : prop\n              });\n            });\n            // if (!track && p.fields) {\n            //   const fieldValues = ret[prop].map(v => v.value);\n            //   ret[prop] = {\n            //     value: typeof p.reduce === 'function' ? p.reduce(fieldValues) : fieldValues\n            //   };\n            // }\n            if (p.fields) {\n              const fieldValues = ret[prop].map(v => v.value);\n              const fieldLabels = ret[prop].map(v => v.label);\n              ret[prop] = {\n                value: typeof p.value === 'function' ? p.value(fieldValues) : typeof p.value !== 'undefined' ? p.value : fieldValues // eslint-disable-line no-nested-ternary\n              };\n              ret[prop].label = typeof p.label === 'function' ? p.label(fieldLabels) : typeof p.label !== 'undefined' ? String(p.label) : String(ret[prop].value); // eslint-disable-line no-nested-ternary\n            }\n          });\n\n          // collect items based on the trackBy value\n          // items with the same trackBy value are placed in an array and reduced later\n          if (track) {\n            util.track({\n              cfg,\n              itemData: mainCell,\n              obj: ret,\n              target: trackedItems,\n              tracker,\n              trackType\n            });\n          }\n\n          items.push(ret);\n        });\n      });\n\n      // reduce if items have been grouped\n      if (track) {\n        dataItems.push(...util.collect(trackedItems, {\n          main,\n          propsArr,\n          props\n        }));\n      } else {\n        dataItems.push(...items);\n      }\n    }\n  });\n  return dataItems;\n}\n","function flattenTree(children, steps, arrIndexAtTargetDepth) {\n  const arr = [];\n  if (!children || !children.length) {\n    return arr;\n  }\n  if (steps <= 0) {\n    const nodes = arrIndexAtTargetDepth >= 0 ? [children[arrIndexAtTargetDepth]] : children;\n    arr.push(...nodes);\n  } else {\n    for (let i = 0; i < children.length; i++) {\n      if (children[i].children && children[i].children.length) {\n        arr.push(...flattenTree(children[i].children, steps - 1, arrIndexAtTargetDepth));\n      }\n    }\n  }\n  return arr;\n}\n\nexport function treeAccessor(sourceDepth, targetDepth, arrIndexAtTargetDepth) {\n  if (sourceDepth === targetDepth) {\n    return d => d;\n  }\n  if (sourceDepth > targetDepth) { // traverse upwards\n    const steps = Math.max(0, Math.min(100, sourceDepth - targetDepth));\n    const path = [...Array(steps)].map(String.prototype.valueOf, 'parent').join('.');\n    return Function('node', `return node.${path};`); // eslint-disable-line no-new-func\n  }\n  if (targetDepth > sourceDepth) { // flatten descendants\n    const steps = Math.max(0, Math.min(100, targetDepth - sourceDepth));\n    return node => flattenTree(node.children, steps - 1, arrIndexAtTargetDepth);\n  }\n  return false;\n}\n\nexport function findField(query, { cache }) {\n  if (typeof query === 'number') {\n    return cache.fields[query];\n  }\n\n  const allFields = cache.allFields;\n  if (typeof query === 'function') {\n    for (let i = 0; i < allFields.length; i++) {\n      if (query(allFields[i])) {\n        return allFields[i];\n      }\n    }\n    return false;\n  } else if (typeof query === 'string') {\n    for (let i = 0; i < allFields.length; i++) {\n      if (allFields[i].key() === query || allFields[i].title() === query) {\n        return allFields[i];\n      }\n    }\n  } else if (query && allFields.indexOf(query) !== -1) { // assume 'query' is a field instance\n    return query;\n  }\n\n  throw Error(`Field not found: ${query}`);\n}\n","import { hierarchy } from 'd3-hierarchy';\n\nimport picker from '../json-path-resolver';\n\nimport { treeAccessor } from './util';\n\nconst DIM_RX = /^qDimensionInfo(?:\\/(\\d+))?/;\nconst M_RX = /^\\/?qMeasureInfo\\/(\\d+)/;\nconst ATTR_EXPR_RX = /\\/qAttrExprInfo\\/(\\d+)/;\nconst ATTR_DIM_RX = /\\/qAttrDimInfo\\/(\\d+)/;\n\nexport function getFieldDepth(field, { cube }) {\n  if (!field) {\n    return -1;\n  }\n  let key = field.key();\n  let isFieldDimension = false;\n  let fieldIdx = -1; // cache.fields.indexOf(field);\n  let attrIdx = -1;\n  let attrDimIdx = -1;\n  let fieldDepth = -1;\n  let pseudoMeasureIndex = -1;\n  let measureIdx = -1;\n  let remainder = key;\n\n  const treeOrder = cube.qEffectiveInterColumnSortOrder;\n\n  if (DIM_RX.test(remainder)) {\n    isFieldDimension = true;\n    fieldIdx = +DIM_RX.exec(remainder)[1];\n    remainder = key.replace(DIM_RX, '');\n  }\n\n  if (M_RX.test(remainder)) {\n    if (cube.qMode === 'K') {\n      pseudoMeasureIndex = +M_RX.exec(remainder)[1];\n    } else if (treeOrder && treeOrder.indexOf(-1) !== -1) {\n      pseudoMeasureIndex = +M_RX.exec(remainder)[1];\n      measureIdx = 0;\n    } else {\n      measureIdx = +M_RX.exec(remainder)[1];\n    }\n    remainder = remainder.replace(M_RX, '');\n  }\n\n  if (remainder) {\n    if (ATTR_DIM_RX.exec(remainder)) {\n      attrDimIdx = +ATTR_DIM_RX.exec(remainder)[1];\n    } else if (ATTR_EXPR_RX.exec(remainder)) {\n      attrIdx = +ATTR_EXPR_RX.exec(remainder)[1];\n    }\n  }\n\n  if (isFieldDimension) {\n    fieldDepth = treeOrder ? treeOrder.indexOf(fieldIdx) : fieldIdx;\n  } else if (treeOrder && treeOrder.indexOf(-1) !== -1) { // if pseudo dimension exists in sort order\n    fieldDepth = treeOrder.indexOf(-1); // depth of pesudodimension\n  } else { // assume measure is at the bottom of the tree\n    fieldDepth = cube.qDimensionInfo.length - (cube.qMode === 'K' ? 0 : 1);\n  }\n\n  return {\n    fieldDepth: fieldDepth + 1, // +1 due to root node\n    pseudoMeasureIndex,\n    measureIdx,\n    attrDimIdx,\n    attrIdx\n  };\n}\n\nfunction getFieldAccessor(sourceDepthObject, targetDepthObject) {\n  let nodeFn = treeAccessor(sourceDepthObject.fieldDepth, targetDepthObject.fieldDepth, targetDepthObject.pseudoMeasureIndex);\n  let valueFn;\n\n  if (targetDepthObject.measureIdx >= 0) {\n    valueFn = node => node.data.qValues[targetDepthObject.measureIdx];\n  } else {\n    valueFn = node => node.data;\n  }\n  let attrFn;\n\n  if (targetDepthObject.attrDimIdx >= 0) {\n    attrFn = data => data.qAttrDims.qValues[targetDepthObject.attrDimIdx];\n  } else if (targetDepthObject.attrIdx >= 0) {\n    attrFn = data => data.qAttrExps.qValues[targetDepthObject.attrIdx];\n  }\n\n  return {\n    nodeFn,\n    attrFn,\n    valueFn\n  };\n}\n\nfunction datumExtract(propCfg, cell, {\n  key\n}) {\n  const datum = {\n    value: typeof propCfg.value === 'function' ? propCfg.value(cell) : typeof propCfg.value !== 'undefined' ? propCfg.value : cell // eslint-disable-line no-nested-ternary\n  };\n\n  datum.label = typeof propCfg.label === 'function' ? propCfg.label(cell) : typeof propCfg.label !== 'undefined' ? String(propCfg.label) : String(datum.value); // eslint-disable-line no-nested-ternary\n\n  if (propCfg.field) {\n    datum.source = {\n      key,\n      field: propCfg.field.key()\n    };\n  }\n\n  return datum;\n}\n\nexport default function extract(config, dataset, cache, util) {\n  const cfgs = Array.isArray(config) ? config : [config];\n  let dataItems = [];\n  cfgs.forEach((cfg) => {\n    if (typeof cfg.field !== 'undefined') {\n      const cube = dataset.raw();\n      const rootPath = cube.qMode === 'K' ? '/qStackedDataPages/*/qData' : '/qTreeDataPages/*';\n      const childNodes = cube.qMode === 'K' ? 'qSubNodes' : 'qNodes';\n      const root = picker(rootPath, cube);\n      if (!root || !root[0]) {\n        return;\n      }\n      const sourceKey = dataset.key();\n      const f = typeof cfg.field === 'object' ? cfg.field : dataset.field(cfg.field);\n      const { props, main } = util.normalizeConfig(cfg, dataset);\n      const propsArr = Object.keys(props);\n      if (!cache.tree) {\n        cache.tree = hierarchy(root[0], node => node[childNodes]);\n      }\n      const itemDepthObject = getFieldDepth(f, { cube, cache });\n      const { nodeFn, attrFn, valueFn } = getFieldAccessor({ fieldDepth: 0 }, itemDepthObject);\n\n      propsArr.forEach((prop) => {\n        const pCfg = props[prop];\n        const arr = pCfg.fields ? pCfg.fields : [pCfg];\n        arr.forEach((p) => {\n          if (p.field) {\n            if (p.field === f) {\n              p.isSame = true;\n            } else {\n              const depthObject = getFieldDepth(p.field, { cube, cache });\n              const accessors = getFieldAccessor(itemDepthObject, depthObject);\n              p.accessor = accessors.nodeFn;\n              p.valueAccessor = accessors.valueFn;\n              p.attrAccessor = accessors.attrFn;\n            }\n          }\n        });\n      });\n\n      const track = !!cfg.trackBy;\n      const trackType = typeof cfg.trackBy;\n      const tracker = {};\n      const trackedItems = [];\n\n      const items = nodeFn(cache.tree);\n      const mapped = [];\n      for (let i = 0; i < items.length; i++) {\n        const item = items[i];\n        const itemData = attrFn ? attrFn(valueFn(item)) : valueFn(item);\n        const exclude = main.filter && !main.filter(itemData);\n        if (exclude) {\n          continue;\n        }\n        const ret = datumExtract(main, itemData, { key: sourceKey });\n        propsArr.forEach((prop) => {\n          const pCfg = props[prop];\n          const arr = pCfg.fields || [pCfg];\n          let coll;\n          if (pCfg.fields) {\n            coll = [];\n          }\n          arr.forEach((p) => {\n            let fn;\n            let value;\n            if (p.type === 'primitive') {\n              value = p.value;\n            } else {\n              if (typeof p.value === 'function') { // accessor function\n                fn = p.value;\n              }\n              if (p.accessor) {\n                value = p.accessor(item);\n                if (Array.isArray(value)) { // propably descendants\n                  value = value.map(p.valueAccessor);\n                  if (p.attrAccessor) {\n                    value = value.map(p.attrAccessor);\n                  }\n                  if (fn) {\n                    value = value.map(fn);\n                    fn = null;\n                  }\n                  value = p.reduce ? p.reduce(value) : value;\n                } else {\n                  value = p.attrAccessor ? p.attrAccessor(p.valueAccessor(value)) : p.valueAccessor(value);\n                }\n              } else {\n                value = itemData;\n              }\n            }\n            if (pCfg.fields) {\n              coll.push(fn ? fn(value) : value);\n            } else {\n              ret[prop] = {\n                value: fn ? fn(value) : value\n              };\n              ret[prop].label = String(ret[prop].value);\n              if (p.field) {\n                ret[prop].source = { field: p.field.key(), key: sourceKey };\n              }\n            }\n          });\n          if (coll) {\n            ret[prop] = {\n              value: typeof pCfg.value === 'function' ? pCfg.value(coll) : coll\n            };\n            ret[prop].label = String(ret[prop].value);\n          }\n        });\n        // collect items based on the trackBy value\n        // items with the same trackBy value are placed in an array and reduced later\n        if (track) {\n          util.track({\n            cfg,\n            itemData,\n            obj: ret,\n            target: trackedItems,\n            tracker,\n            trackType\n          });\n        }\n        mapped.push(ret);\n      }\n      // reduce if items have been grouped\n      if (track) {\n        dataItems.push(...util.collect(trackedItems, {\n          main,\n          propsArr,\n          props\n        }));\n      } else {\n        dataItems.push(...mapped);\n      }\n    }\n  });\n  return dataItems;\n}\n","import formatter from 'number-format.js';\n\nfunction escapeRegExp(str) {\n  return str.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, '\\\\$&');\n}\n\nconst SIprefixes = {\n    3: 'k',\n    6: 'M',\n    9: 'G',\n    12: 'T',\n    15: 'P',\n    18: 'E',\n    21: 'Z',\n    24: 'Y',\n    '-3': 'm',\n    '-6': '',\n    '-9': 'n',\n    '-12': 'p',\n    '-15': 'f',\n    '-18': 'a',\n    '-21': 'z',\n    '-24': 'y'\n  },\n  percentage = /%$/,\n  //    scientific = /e[\\+\\-][0-9]+/,\n  radix = /^\\(r(0[2-9]|[12]\\d|3[0-6])\\)/i,\n  oct = /^\\(oct\\)/i,\n  dec = /^\\(dec\\)/i,\n  hex = /^\\(hex\\)/i,\n  bin = /^\\(bin\\)/i,\n  rom = /^\\(rom\\)/i,\n  functional = /^(\\(rom\\)|\\(bin\\)|\\(hex\\)|\\(dec\\)|\\(oct\\)|\\(r(0[2-9]|[12]\\d|3[0-6])\\))/i,\n  prec = /#|0/g;\n\nfunction formatRadix(value, fradix, pattern, decimal) {\n  value = value.toString(fradix);\n  if (pattern[1] === pattern[1].toUpperCase()) {\n    value = value.toUpperCase();\n  }\n  if (value.length - value.indexOf('.') > 10) { // limit to 10 decimal places\n    value = value.slice(0, value.indexOf('.') + 11);\n  }\n\n  return value.replace('.', decimal || '.');\n}\n\n// value must be an integer\n// value must not be in scientific notation\nfunction formatRoman(value, pattern) {\n  let i,\n    s = '',\n    v = Number(String(value).slice(-3)),\n    nThousands = (value - v) / 1000,\n    decimal = [0, 1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900].reverse(),\n    numeral = ['0', 'I', 'IV', 'V', 'IX', 'X', 'XL', 'L', 'XC', 'C', 'CD', 'D', 'CM'].reverse();\n\n  while (v > 0) {\n    for (i = 0; i < decimal.length; i++) {\n      if (decimal[i] <= v) {\n        s += numeral[i];\n        v -= decimal[i];\n        break;\n      }\n    }\n  }\n\n  for (i = 0; i < nThousands; i++) {\n    s = `M${s}`;\n  }\n\n  if (pattern[1] !== pattern[1].toUpperCase()) {\n    s = s.toLowerCase();\n  }\n  return s;\n}\n\nfunction formatFunctional(value, pattern, d) {\n  let temp;\n  if (radix.test(pattern)) {\n    value = formatRadix(value, Number(/\\d{2}/.exec(pattern)[0]), pattern, d);\n  } else if (oct.test(pattern)) {\n    value = formatRadix(value, 8, pattern, d);\n  } else if (dec.test(pattern)) {\n    value = formatRadix(value, 10, pattern, d);\n  } else if (hex.test(pattern)) {\n    value = formatRadix(value, 16, pattern, d);\n  } else if (bin.test(pattern)) {\n    value = formatRadix(value, 2, pattern, d);\n  } else if (rom.test(pattern)) {\n    temp = '';\n    if (value < 0) {\n      temp = '-';\n      value = -value;\n    }\n    value = Math.floor(value);\n    if (value === 0) {\n      value = '0';\n    } else if (value <= 500000) { // limit in engine\n      value = formatRoman(value, pattern);\n      value = temp + value;\n    } else {\n      value = pattern + temp + value.toExponential(0); // to return same result as engine\n    }\n  }\n\n  return value;\n}\n\nfunction escape(value, flags, justStr) {\n  const str = escapeRegExp(value);\n  if (justStr) {\n    return str;\n  }\n  return new RegExp(str || '', flags);\n}\n\nfunction createRegExp(thousand, decimal) {\n  if (decimal) {\n    decimal = escapeRegExp(decimal);\n  }\n  if (thousand) {\n    thousand = escapeRegExp(thousand);\n  }\n  return new RegExp(`(?:[#0]+${thousand})?[#0]+(?:${decimal}[#0]+)?`);\n}\n\nfunction getAbbreviations(localeInfo, listSeparator) {\n  if (!localeInfo || !localeInfo.qNumericalAbbreviation) {\n    return SIprefixes;\n  }\n\n  const abbreviations = {};\n  let abbrs = localeInfo.qNumericalAbbreviation.split(listSeparator);\n\n  abbrs.forEach((abbreviation) => {\n    let abbreviationTuple = abbreviation.split(':');\n    if (abbreviationTuple.length === 2) {\n      abbreviations[abbreviationTuple[0]] = abbreviationTuple[1];\n    }\n  });\n\n  return abbreviations;\n}\n\nfunction preparePattern(o, t, d) {\n  let parts,\n    lastPart,\n    pattern = o.pattern,\n    numericPattern,\n    prefix,\n    postfix,\n    groupTemp,\n    decTemp,\n    temp,\n    regex;\n\n  if (pattern.indexOf('A') >= 0) { // abbreviate SI\n    pattern = pattern.replace('A', '');\n    o.abbreviate = true;\n  }\n\n  // extract the numeric part from the pattern\n  regex = createRegExp(t, d);\n  numericPattern = pattern.match(regex);\n  numericPattern = numericPattern ? numericPattern[0] : '';\n  prefix = numericPattern ? pattern.substr(0, pattern.indexOf(numericPattern)) : pattern;\n  postfix = numericPattern ? pattern.substring(pattern.indexOf(numericPattern) + numericPattern.length) : '';\n\n  if (!numericPattern) {\n    numericPattern = pattern ? '#' : '##########';\n  }\n\n  if (t && t === d) { // ignore grouping if grouping separator is same as decimal separator\n    // extract decimal part\n    parts = numericPattern.split(d);\n    lastPart = parts.pop();\n    numericPattern = parts.join('') + d + lastPart;\n    t = '';\n  }\n\n  // formatting library does not support multiple characters as separator (nor +-).\n  // do a temporary replacement\n  groupTemp = t;\n  t = /,/.test(d) ? '' : ',';\n  if (groupTemp) {\n    numericPattern = numericPattern.replace(escape(groupTemp, 'g'), t);\n  }\n\n  decTemp = d;\n  d = '.';\n  if (decTemp) {\n    numericPattern = numericPattern.replace(escape(decTemp, 'g'), d);\n  }\n\n  temp = numericPattern.match(/#/g);\n  temp = temp ? temp.length : 0;\n\n  const splitPattern = pattern.split(decTemp);\n  let matchPrecisionResult;\n  if (splitPattern[1]) {\n    matchPrecisionResult = splitPattern[1].match(prec);\n  }\n\n  o.prefix = prefix || '';\n  o.postfix = postfix || '';\n  o.pattern = pattern;\n  o.maxPrecision = matchPrecisionResult ? matchPrecisionResult.length : 2;\n  o.percentage = percentage.test(pattern);\n  o.numericPattern = numericPattern || '';\n  o.numericRegex = new RegExp(`${escape(t, null, true)}|${escape(d, null, true)}`, 'g');\n  o.groupTemp = groupTemp;\n  o.decTemp = decTemp;\n  o.t = t;\n  o.d = d;\n  o.temp = temp;\n}\n\nclass NumberFormatter {\n  /**\n   * @name NumberFormatter\n   * @constructs\n   * @param {Object} localeInfo\n   * @param {String} pattern\n   * @param {String} [thousand]\n   * @param {String} [decimal]\n   * @param {String} [type]\n   */\n  constructor(localeInfo, pattern, thousand, decimal, type) {\n    this.localeInfo = localeInfo;\n    this.pattern = pattern;\n    this.thousandDelimiter = thousand || ',';\n    this.decimalDelimiter = decimal || '.';\n    this.type = type || 'numeric';\n\n    // FIXME qListSep?\n    // this.patternSeparator = this.localeInfo && this.localeInfo.qListSep ? this.localeInfo.qListSep : ';';\n    this.patternSeparator = ';';\n\n    this.abbreviations = getAbbreviations(localeInfo, this.patternSeparator);\n\n    this.prepare();\n  }\n\n  clone() {\n    const n = new NumberFormatter(this.localeInfo, this.pattern, this.thousandDelimiter, this.decimalDelimiter, this.type);\n    n.subtype = this.subtype;\n    return n;\n  }\n\n  /**\n   * Formats a number according to a specific pattern.\n   * Use # for optional numbers and 0 for padding.\n   * @param {Number} value Number to format.\n   * @param {String} [pattern] The pattern to apply.\n   * @param {String} [t] Grouping separator.\n   * @param {String} [d] Decimal delimiter.\n   * @example\n   * format(10, \"0\") // 10;\n   * format(10, \"#\") // 10;\n   * format(10, \"##.#\") // 10;\n   * format(10, \"##.0\") // 10.0;\n   * format(10, \"000\") // 010;\n   * format(10.123, \"0.0\") // 10.1;\n   * format(10.123, \"0.00##\") // 10.123; // at least 2 decimals, never more than 4\n   * format(123456789, \"#,###\") // 123,456,789;\n   * format(123456789, \"####-####\", \"-\") // 1-2345-6789;\n   * format(10000, \"#A\") // 10k,  A -> SI abbreviation\n   * format(1234567, \"#.###A\") // 1.235M;\n   * format(0.0001, \"#.#A\") // 0.1m;\n   *\n   * format(0.257, \"0.0%\") // 25.7%; // will multiply by 100\n   * format(9876, \"$#,###\") // $9,876;\n   * format(-9876, \"$#,###;$(#,###)\") // $(9,876); // use ; for alternative formatting for negative values\n   * format(10, \"(r16)\") // a; // radix 16\n   * format(15, \"(hex)\") // f; // same as (r16)\n   * format(15, \"(HEX)\") // F;\n   * format(10, \"(bin)\") // 1010; // same as (r02)\n   * format(10, \"(oct)\") // 12; // same as (r08)\n   */\n  format(value, pattern, t, d) {\n    this.prepare(pattern, t, d);\n    return this.formatValue(value);\n  }\n\n  prepare(pattern, t, d) {\n    let prep;\n\n    if (typeof pattern === 'undefined') { pattern = this.pattern; }\n    if (typeof t === 'undefined') { t = this.thousandDelimiter; }\n    if (typeof d === 'undefined') { d = this.decimalDelimiter; }\n\n\n    if (!pattern) {\n      this._prepared = { pattern: false };\n      return;\n    }\n\n    this._prepared = {\n      positive: {\n        d,\n        t,\n        abbreviate: false,\n        isFunctional: false,\n        prefix: '',\n        postfix: ''\n      },\n      negative: {\n        d,\n        t,\n        abbreviate: false,\n        isFunctional: false,\n        prefix: '',\n        postfix: ''\n      },\n      zero: {\n        d,\n        t,\n        abbreviate: false,\n        isFunctional: false,\n        prefix: '',\n        postfix: ''\n      }\n    };\n    prep = this._prepared;\n\n    pattern = pattern.split(this.patternSeparator);\n    prep.positive.pattern = pattern[0];\n    prep.negative.pattern = pattern[1];\n    prep.zero.pattern = pattern[2];\n    if (functional.test(pattern[0])) {\n      prep.positive.isFunctional = true;\n    }\n    if (!pattern[1]) {\n      prep.negative = false;\n    } else if (functional.test(pattern[1])) {\n      prep.negative.isFunctional = true;\n    }\n    if (!pattern[2]) {\n      prep.zero = false;\n    } else if (functional.test(pattern[2])) {\n      prep.zero.isFunctional = true;\n    }\n\n    if (!prep.positive.isFunctional) {\n      preparePattern(prep.positive, t, d);\n    }\n    if (prep.negative && !prep.negative.isFunctional) {\n      preparePattern(prep.negative, t, d);\n    }\n    if (prep.zero && !prep.zero.isFunctional) {\n      preparePattern(prep.zero, t, d);\n    }\n  }\n\n  formatValue(value) {\n    let prep = this._prepared,\n      temp,\n      exponent,\n      abbr = '',\n      absValue,\n      num,\n      sciValue = '',\n      d,\n      t,\n      i,\n      numericPattern,\n      decimalPartPattern,\n      original = value;\n\n    if (isNaN(value)) {\n      return `${original}`;\n    }\n\n    value = +value;\n\n    if (prep.pattern === false) {\n      return value.toString();\n    }\n\n    if (value === 0 && prep.zero) {\n      prep = prep.zero;\n      return prep.pattern;\n    } else if (value < 0 && prep.negative) {\n      prep = prep.negative;\n      value = -value;\n    } else {\n      prep = prep.positive;\n    }\n    d = prep.d;\n    t = prep.t;\n\n    if (prep.isFunctional) {\n      value = formatFunctional(value, prep.pattern, d);\n    } else {\n      if (prep.percentage) {\n        value *= 100;\n      }\n\n      if (prep.abbreviate) {\n        const abbrArray = Object.keys(this.abbreviations).map(key => parseInt(key, 10)).sort((a, b) => a - b);\n        let lowerAbbreviation;\n        let upperAbbreviation = abbrArray[0];\n        i = 0;\n        exponent = Number(Number(value).toExponential().split('e')[1]);\n\n        while (upperAbbreviation <= exponent && i < abbrArray.length) {\n          i++;\n          upperAbbreviation = abbrArray[i];\n        }\n\n        if (i > 0) {\n          lowerAbbreviation = abbrArray[i - 1];\n        }\n\n        let suggestedAbbrExponent;\n\n        // value and lower abbreviation is for values above 10, use the lower (move to the left <==)\n        if ((lowerAbbreviation && exponent > 0 && lowerAbbreviation > 0)) {\n          suggestedAbbrExponent = lowerAbbreviation;\n        // value and lower abbreviation is for values below 0.1 (move to the right ==>)\n        } else if ((exponent < 0 && lowerAbbreviation < 0) || !lowerAbbreviation) {\n          // upper abbreviation is also for values below 0.1 and precision allows for using the upper abbreviation(move to the right ==>)\n          if (upperAbbreviation < 0 && (upperAbbreviation - exponent) <= prep.maxPrecision) {\n            suggestedAbbrExponent = upperAbbreviation;\n          // lower abbrevaition is smaller than exponent and we can't get away with not abbreviating\n          } else if (lowerAbbreviation <= exponent && !(upperAbbreviation > 0 && -exponent <= prep.maxPrecision)) { // (move to left <==)\n            suggestedAbbrExponent = lowerAbbreviation;\n          }\n        }\n        if (suggestedAbbrExponent) {\n          abbr = this.abbreviations[suggestedAbbrExponent];\n          value /= Math.pow(10, suggestedAbbrExponent);\n        }\n      }\n\n      absValue = Math.abs(value);\n      temp = prep.temp;\n      numericPattern = prep.numericPattern;\n      decimalPartPattern = numericPattern.split(d)[1];\n\n      if (this.type === 'I') {\n        value = Math.round(value);\n      }\n      num = value;\n\n      if (!decimalPartPattern && numericPattern.slice(-1)[0] === '#') {\n        if (absValue >= Math.pow(10, temp) || absValue < 1 || absValue < 1e-4) {\n          if (value === 0) {\n            value = '0';\n          } else if (absValue < 1e-4 || absValue >= 1e20) { // engine always formats values < 1e-4 in scientific form, values >= 1e20 can only be represented in scientific form\n            value = num.toExponential(Math.max(1, Math.min(14, temp)) - 1);\n            value = value.replace(/\\.?0+(?=e)/, '');\n            sciValue = '';\n          } else {\n            value = value.toPrecision(Math.max(1, Math.min(14, temp)));\n            if (value.indexOf('.') >= 0) {\n              value = value.replace(value.indexOf('e') < 0 ? /0+$/ : /\\.?0+(?=e)/, '');\n              value = value.replace('.', d);\n            }\n          }\n        } else {\n          numericPattern += d;\n          temp = Math.max(0, Math.min(20, temp - Math.ceil(Math.log(absValue) / Math.log(10))));\n          for (i = 0; i < temp; i++) {\n            numericPattern += '#';\n          }\n\n          value = formatter(numericPattern, value);\n        }\n      } else if (absValue >= 1e15 || (absValue > 0 && absValue <= 1e-14)) {\n        value = absValue ? absValue.toExponential(15).replace(/\\.?0+(?=e)/, '') : '0';\n      } else {\n        const wholePart = Number((value.toFixed(Math.min(20, decimalPartPattern ? decimalPartPattern.length : 0))).split('.')[0]);\n        let wholePartPattern = numericPattern.split(d)[0];\n        wholePartPattern += d;\n\n        value = formatter(wholePartPattern, wholePart) || '0';\n\n        if (decimalPartPattern) {\n          const nDecimals = Math.max(0, Math.min(14, decimalPartPattern.length)); // the length of e.g. 0000#####\n          const nZeroes = decimalPartPattern.replace(/#+$/, '').length;\n          let decimalPart = (this.type === 'I' ? 0 : absValue % 1).toFixed(nDecimals).slice(2).replace(/0+$/, ''); // remove trailing zeroes\n\n          for (i = decimalPart.length; i < nZeroes; i++) {\n            decimalPart += '0';\n          }\n\n          if (decimalPart) {\n            value += d + decimalPart;\n          }\n        } else if (wholePart === 0) { // to avoid \"-\" being prefixed to value\n          num = 0;\n        }\n      }\n\n      value = value.replace(prep.numericRegex, (m) => {\n        if (m === t) {\n          return prep.groupTemp;\n        } else if (m === d) {\n          return prep.decTemp;\n        }\n        return '';\n      });\n      if (num < 0 && !/^-/.test(value)) {\n        value = `-${value}`;\n      }\n    }\n\n    return prep.prefix + value + sciValue + abbr + prep.postfix;\n  }\n\n  static getStaticFormatter() {\n    return { prepare() { }, formatValue(v) { return `${v}`; } };\n  }\n}\n\nexport default function numberFormatFactory(...args) {\n  return new NumberFormatter(...args);\n}\n","import numberFormatFactory from './parts/qs-number-formatter';\n\nexport default function formatter(pattern, thousand, decimal, qType, localeInfo) {\n  const qformat = numberFormatFactory(localeInfo, pattern, thousand, decimal, qType);\n\n  /**\n   * Format a value according to the specified pattern created at construct\n   *\n   * @param  {Number} value   The number to be formatted\n   * @return {String}         [description]\n   */\n  function format(value) {\n    return qformat.formatValue(value);\n  }\n\n  /**\n    * Format a value according to a specific pattern\n    * that is not the one specified in the constructor\n    *\n    * @param  {String} p   Pattern\n    * @param  {Number} v   Value\n    * @param  {String} t   Thousand\n    * @param  {String} d   Decimal\n    * @return {String}     Formatted value\n    */\n  format.format = function formatFn(p, v, t, d) {\n    return qformat.format(v, p, t, d);\n  };\n\n  /**\n    * Change the pattern on existing formatter\n    *\n    * @param  {String} p     Pattern (optional)\n    * @return {String}       Returns the pattern\n    */\n  format.pattern = function patternFn(p) {\n    if (p) {\n      qformat.pattern = p;\n      qformat.prepare();\n    }\n    return qformat.pattern;\n  };\n\n  /**\n   * Set the locale for the formatter\n   *\n   * @param  {Object} args   Locale object for formatting\n   * @return {Undefined}      Returns nothing\n   */\n  /* format.locale = function( ...args ) {\n    locale = formatLocale( ...args );\n    d3format = locale.format( pattern );\n\n    return this;\n  }; */\n\n  return format;\n}\n","import { TYPES } from '../timeFormat';\n\nconst DAYS = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];\nconst DAYS_ABBR = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];\nconst MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\nconst MONTHS_ABBR = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\nfunction pad(s, n) {\n  for (let i = s.length; i < n; i++) {\n    s = `0${s}`;\n  }\n  return s;\n}\n\nfunction parseDate(d, twelveFormat) {\n  let h = d.getHours();\n  let day = d.getDay() - 1;\n  if (twelveFormat) {\n    h %= 12;\n    if (!h) { // h == 0 -> 12\n      h = 12;\n    }\n  }\n\n  if (day < 0) {\n    day = 6;\n  }\n\n  return {\n    year: d.getFullYear(),\n    month: d.getMonth(),\n    day,\n    date: d.getDate(),\n    h,\n    m: d.getMinutes(),\n    s: d.getSeconds(),\n    f: d.getMilliseconds(),\n    t: d.getHours() >= 12 ? 'pm' : 'am'\n  };\n}\n\nfunction getRemainder(value) {\n  let s = value.toString().split('.');\n  if (s[1]) {\n    s = Number(`0.${s[1]}`);\n  } else {\n    return 0;\n  }\n  return s;\n}\n\nfunction parseIntervalDays(days) {\n  const d = days;\n  const h = 24 * getRemainder(d);\n  const m = 60 * getRemainder(h);\n  const s = 60 * getRemainder(m);\n  const ms = 1000 * getRemainder(s);\n\n  return {\n    d: Math.floor(d),\n    h: Math.floor(h),\n    m: Math.floor(m),\n    s: Math.floor(s),\n    f: Math.round(ms)\n  };\n}\n\nfunction parseInterval(days, pattern) {\n  let units = parseIntervalDays(days),\n    d = units.d,\n    h = units.h,\n    m = units.m,\n    s = units.s,\n    f = units.f,\n    w = 0,\n    date;\n\n  if (/w+|t+/gi.test(pattern)) {\n    date = new Date(1899, 11, 30 + Math.floor(days), 0, 0, 24 * 60 * 60 * (days - Math.floor(days)));\n    if (isNaN(date.getTime())) {\n      date = null;\n    }\n  }\n\n  if (!/D+/gi.test(pattern)) {\n    h += d * 24;\n  }\n  if (!/h+/gi.test(pattern)) {\n    m += h * 60;\n  }\n  if (!/m+/gi.test(pattern)) {\n    s += m * 60;\n  }\n  if (/w+/gi.test(pattern)) {\n    w = date ? date.getDay() - 1 : 0;\n    if (w < 0) {\n      w = 6;\n    }\n  }\n\n  let someT = '';\n  if (date) {\n    someT = date.getHours() >= 12 ? 'pm' : 'am';\n  }\n\n  return {\n    year: 0,\n    month: 0,\n    day: w,\n    date: d,\n    h,\n    m,\n    s,\n    f,\n    t: someT\n  };\n}\n\nfunction getMasks(inst, d) {\n  return {\n    'Y+|y+': {\n      Y: `${Number((`${d.year}`).slice(-2))}`,\n      YY: pad((`${d.year}`).slice(-2), 2),\n      YYY: pad((`${d.year}`).slice(-3), 3),\n      def(m) { // default\n        return pad((`${d.year}`), m.length);\n      }\n    },\n    'M+': {\n      M: d.month + 1,\n      MM: pad(`${d.month + 1}`, 2),\n      MMM: inst.locale_months_abbr[d.month],\n      def: inst.locale_months[d.month]\n    },\n    'W+|w+': {\n      W: d.day,\n      WW: pad(`${d.day}`, 2),\n      WWW: inst.locale_days_abbr[d.day],\n      def: inst.locale_days[d.day]\n    },\n    'D+|d+': {\n      D: d.date,\n      def(m) {\n        return pad(`${d.date}`, m.length);\n      }\n    },\n    'h+|H+': {\n      h: d.h,\n      def(m) { return pad(`${d.h}`, m.length); }\n    },\n    'm+': {\n      m: d.m,\n      def(m) { return pad(`${d.m}`, m.length); }\n    },\n    's+|S+': {\n      s: d.s,\n      def(m) { return pad(`${d.s}`, m.length); }\n    },\n    'f+|F+': {\n      def(m) {\n        let f = `${d.f}`,\n          n = m.length - f.length;\n        if (n > 0) {\n          for (let i = 0; i < n; i++) {\n            f += '0';\n          }\n        } else if (n < 0) {\n          f = f.slice(0, m.length);\n        }\n        return f;\n      }\n    },\n    't{1,2}|T{1,2}': {\n      def(m) {\n        let t = d.t;\n        if (m[0].toUpperCase() === m[0]) {\n          t = t.toUpperCase();\n        }\n        t = t.slice(0, m.length);\n        return t;\n      }\n    }\n  };\n}\n\nclass DateFormatter {\n  /**\n   * @name DateFormatter\n   * @constructs\n   * @param {Object} localeInfo\n   * @param {String} pattern\n   */\n  constructor(localeInfo, pattern, qtype) {\n    const info = localeInfo || {};\n\n    if (!info.qCalendarStrings) {\n      info.qCalendarStrings = {\n        qLongDayNames: DAYS,\n        qDayNames: DAYS_ABBR,\n        qLongMonthNames: MONTHS,\n        qMonthNames: MONTHS_ABBR\n      };\n    }\n\n    this.localeInfo = info;\n    this.locale_days = info.qCalendarStrings.qLongDayNames.slice();\n    this.locale_days_abbr = info.qCalendarStrings.qDayNames.slice();\n    this.locale_months = info.qCalendarStrings.qLongMonthNames.slice();\n    this.locale_months_abbr = info.qCalendarStrings.qMonthNames.slice();\n\n    if (!pattern) {\n      const patternMap = {\n        [TYPES.TIME]: info.qTimeFmt || 'hh:mm:ss',\n        [TYPES.DATE]: info.qDateFmt || 'YYYY-MM-DD',\n        [TYPES.DATE_TIME]: info.qTimestampFmt || 'YYYY-MM-DD hh:mm:ss'\n      };\n\n      pattern = patternMap[qtype];\n    }\n\n    this.pattern = pattern;\n  }\n\n  clone() {\n    const n = new DateFormatter(this.localeInfo, this.pattern);\n    n.subtype = this.subtype;\n    return n;\n  }\n\n  /**\n   * Formats a date according to given pattern\n   * @param {Date} date The date to format.\n   * @param {String} pattern The desired format of the date\n   * var d = new Date(2013, 8, 15, 13, 55, 40, 987);\n   * var n = new DateFormatter();\n   * @example\n   * m.format( d, 'YYYY-MM-DD hh:mm:ss.ffff') // 2013-08-15 13:55:40.9870\n   * m.format( d, 'h:m:s tt') // 1:55:40 pm\n   * m.format( d, 'h:m:s TT') // 1:55:40 PM\n   * m.format( d, 'M/D/YYYY') // 8/15/2013\n   * m.format( d, 'WWWW DD MMM') // Thursday 15 Aug\n   * m.format( d, 'WWW DD MMMM @ hh:mm:ss') // Thu 15 August @ 13:55:40\n   */\n  format(date, pattern) {\n    // Fallback pattern is set in constructor\n    if (!pattern) {\n      pattern = this.pattern ? this.pattern : 'YYYY-MM-DD hh:mm:ss';\n    }\n\n    pattern = pattern.replace(/\\[.+]|\\[|]/g, '');\n    const hasTwelveFlag = /t+/ig.test(pattern);\n    let parsedDate;\n\n    if (date instanceof Date) {\n      parsedDate = parseDate(date, hasTwelveFlag);\n    } else {\n      if (date < 0) {\n        // parseInterval don't support for negative values\n        date = -date;\n        pattern = `-${pattern}`;\n      }\n      parsedDate = parseInterval(date, pattern);\n    }\n    // remove [] and everything inside it\n\n    const masks = getMasks(this, parsedDate);\n\n    const masksArr = [];\n    for (const mask in masks) {\n      if (Object.prototype.hasOwnProperty.call(masks, mask)) {\n        masksArr.push(mask);\n      }\n    }\n    const dateTimeRegex = new RegExp(masksArr.join('|'), 'g');\n\n    const result = pattern.replace(dateTimeRegex, (m) => {\n      let r;\n      let mask;\n      for (mask in masks) {\n        if (Object.prototype.hasOwnProperty.call(masks, mask)) {\n          r = new RegExp(mask);\n          if (r.test(m)) {\n            break;\n          }\n        }\n      }\n      if (!r) {\n        return '';\n      }\n      let value;\n      for (const submask in masks[mask]) {\n        if (submask === m || submask.toLowerCase() === m) {\n          value = masks[mask][submask];\n          if (typeof value === 'undefined') {\n            value = masks[mask][submask.toLowerCase()];\n          }\n          break;\n        }\n      }\n      if (typeof value === 'undefined') {\n        value = masks[mask].def;\n      }\n\n      if (typeof value === 'function') {\n        value = value(m);\n      }\n      return value;\n    });\n    return result;\n  }\n}\n\nexport default function dateFormatFactory(...args) {\n  return new DateFormatter(...args);\n}\n","import dateFormatFactory from './parts/qs-date-formatter';\n\nexport function QlikTimeToDate(value) {\n  return new Date(1899, 11, 30 + Math.floor(value), 0, 0, 0, 1000 * 24 * 60 * 60 * (value - Math.floor(value)));\n}\n\nexport const TYPES = {\n  AUTO: 'U',\n  INTEGER: 'I',\n  NUMBER: 'R',\n  FIXED_TO: 'F',\n  MONEY: 'M',\n  DATE: 'D',\n  TIME: 'T',\n  DATE_TIME: 'TS',\n  INTERVAL: 'IV'\n};\n\nexport default function formatter(pattern, qtype = 'TS', localeInfo = null) {\n  let qformat = dateFormatFactory(localeInfo, pattern, qtype);\n\n  /**\n   * Prepare a value according to the specified qtype\n   *\n   * @param  {Number} value The value to be formatted\n   * @return {Number}       The converted value (if applied)\n   */\n  function prepare(value) {\n    if (qtype !== TYPES.INTERVAL) {\n      return QlikTimeToDate(value);\n    }\n    return value;\n  }\n\n  /**\n   * Format a value according to the specified pattern created at construct\n   *\n   * @param  {Date} value   The number to be formatted\n   * @return {String}         [description]\n   */\n  function format(value) {\n    value = prepare(value);\n    return qformat.format(value);\n  }\n\n  /**\n    * Format a value according to a specific pattern\n    * that is not the one specified in the constructor\n    *\n    * @param  {String} p   Pattern\n    * @param  {Date} v   Value\n    * @return {String}     Formatted value\n    */\n  format.format = function formatFn(p, v) {\n    v = prepare(v);\n    return qformat.format(v, p);\n  };\n\n  /**\n   * Set the locale for the formatter\n   *\n   * @param  {Object} args   Locale object for formatting\n   * @return {Undefined}      Returns nothing\n   */\n  format.locale = function locale(li) {\n    qformat = dateFormatFactory(li, pattern, qtype);\n\n    return this;\n  };\n\n  /**\n   * Get or set the QType\n   *\n   * @param  {String} nqt New qType (optional)\n   * @return {String}     Current qtype\n   */\n  format.qtype = function qtypeFn(nqt) {\n    if (nqt !== undefined) {\n      qtype = nqt;\n    }\n    return qtype;\n  };\n\n  return format;\n}\n","import { createFromMetaInfo } from '../formatter';\n\nexport default function qField({\n  meta,\n  id,\n  key,\n  localeInfo,\n  fieldExtractor,\n  value,\n  type\n} = {}) {\n  let values;\n\n  const valueFn = value || (type === 'dimension' ? (d => d.qElemNo) : (d => d.qValue));\n  const labelFn = d => d.qText || '';\n  const reduce = type === 'dimension' ? 'first' : 'avg';\n  const formatter = createFromMetaInfo(meta, localeInfo);\n\n  const f = {\n    id: () => id,\n    key: () => key,\n    raw: () => meta,\n    title: () => meta.qFallbackTitle || meta.label,\n    type: () => type,\n    items: () => {\n      if (!values) {\n        values = fieldExtractor(f);\n      }\n      return values;\n    },\n    min: () => meta.qMin,\n    max: () => meta.qMax,\n    value: valueFn,\n    label: labelFn,\n    reduce,\n    formatter: () => formatter,\n    tags: () => meta.qTags\n  };\n\n  return f;\n}\n","import numberFormat from './numberFormat';\nimport timeFormat from './timeFormat';\n\nexport {\n  numberFormat,\n  timeFormat\n};\n\nexport function createFromMetaInfo(meta, localeInfo) {\n  if (meta && meta.qNumFormat && ['D', 'T', 'TS', 'IV'].indexOf(meta.qNumFormat.qType) !== -1) {\n    return timeFormat(meta.qNumFormat.qFmt, meta.qNumFormat.qType, localeInfo);\n  }\n  let pattern = '#';\n  let thousand = localeInfo && typeof localeInfo.qThousandSep !== 'undefined' ? localeInfo.qThousandSep : ',';\n  let decimal = localeInfo && typeof localeInfo.qDecimalSep !== 'undefined' ? localeInfo.qDecimalSep : '.';\n  let type = 'U';\n  let isAuto = meta && !!meta.qIsAutoFormat;\n  if (meta && meta.qNumFormat) {\n    pattern = meta.qNumFormat.qFmt || pattern;\n    thousand = meta.qNumFormat.qThou || thousand;\n    decimal = meta.qNumFormat.qDec || decimal;\n    type = meta.qNumFormat.qType || type;\n    isAuto = isAuto && ['M'].indexOf(meta.qNumFormat.qType) === -1;\n  } else {\n    isAuto = true;\n  }\n\n  if (isAuto || type === 'U') {\n    pattern = `#${decimal}##A`;\n    type = 'U';\n  }\n\n  return numberFormat(pattern, thousand, decimal, type, localeInfo);\n}\n","import extend from 'extend';\nimport augmentH from './augment-hierarchy';\nimport SExtractor from './extractor-s';\nimport TExtractor from './extractor-t';\nimport { findField } from './util';\nimport field from './field';\n\nfunction hierarchy(config = {}, dataset, cache, deps) {\n  const cube = dataset.raw();\n  if (cube.qMode !== 'K') {\n    return null;\n  }\n  return augmentH(config, dataset, cache, deps);\n}\n\nfunction createFields(path, obj, prefix, parentKey, opts) {\n  return (obj[path] || []).map((meta, i) => {\n    const fieldKey = `${parentKey ? `${parentKey}/` : ''}${path}/${i}`;\n    const f = {\n      instance: field(extend({\n        id: `${prefix ? `${prefix}/` : ''}${fieldKey}`,\n        key: fieldKey,\n        meta\n      }, opts))\n    };\n    f.attrDims = createFields('qAttrDimInfo', meta, prefix, fieldKey, extend({}, opts, { value: v => v.qElemNo, type: 'dimension' }));\n    f.attrExps = createFields('qAttrExprInfo', meta, prefix, fieldKey, extend({}, opts, { value: v => v.qNum, type: 'measure' }));\n    f.measures = createFields('qMeasureInfo', meta, prefix, fieldKey, extend({}, opts, { value: v => v.qValue, type: 'measure' }));\n    return f;\n  });\n}\n\nexport default function q({\n  key,\n  data,\n  config = {}\n} = {}) {\n  const cache = {\n    fields: [],\n    wrappedFields: [],\n    allFields: []\n  };\n\n  const cube = data;\n  if (!cube) {\n    throw new Error('Missing \"data\" input');\n  }\n\n  if (!cube.qDimensionInfo) {\n    throw new Error('The \"data\" input is not recognized as a hypercube');\n  }\n\n  const deps = q.util;\n\n  const opts = {\n    cache,\n    cube,\n    localeInfo: config.localeInfo,\n    fieldExtractor: null,\n    pages: null\n  };\n\n  const dataset = {\n    key: () => key,\n    raw: () => cube,\n    field: query => findField(query, opts),\n    fields: () => cache.fields.slice(),\n    extract: extractionConfig => opts.extractor(extractionConfig, dataset, cache, deps),\n    hierarchy: hierarchyConfig => hierarchy(hierarchyConfig, dataset, cache, deps),\n    _cache: () => cache\n  };\n\n  if (cube.qMode === 'K' || cube.qMode === 'T' || (!cube.qMode && cube.qNodesOnDim)) {\n    opts.extractor = TExtractor;\n    opts.pages = cube.qMode === 'K' ? cube.qStackedDataPages : cube.qTreeDataPages;\n  } else if (cube.qMode === 'S') {\n    opts.extractor = SExtractor;\n    opts.pages = cube.qDataPages;\n  } else {\n    opts.ectractor = () => []; // TODO - throw unsupported error?\n  }\n\n  opts.fieldExtractor = f => opts.extractor({ field: f }, dataset, cache, deps);\n\n  const dimAcc = cube.qMode === 'S' ? (d => d.qElemNumber) : undefined;\n  const measAcc = cube.qMode === 'S' ? (d => d.qNum) : undefined;\n\n  cache.wrappedFields.push(...createFields('qDimensionInfo', cube, key, '', extend({}, opts, { value: dimAcc, type: 'dimension' })));\n  cache.wrappedFields.push(...createFields('qMeasureInfo', cube, key, '', extend({}, opts, { value: measAcc, type: 'measure' })));\n\n  cache.fields = cache.wrappedFields.map(f => f.instance);\n\n  const traverse = (arr) => {\n    arr.forEach((f) => {\n      cache.allFields.push(f.instance);\n      traverse(f.measures);\n      traverse(f.attrDims);\n      traverse(f.attrExps);\n    });\n  };\n\n  traverse(cache.wrappedFields);\n\n  return dataset;\n}\n","import resolve from '../json-path-resolver';\n\nconst LAYOUT_TO_PROP = [\n  ['qHyperCube', 'qHyperCubeDef'],\n  ['qTreeData', 'qTreeDataDef'],\n  ['qDimensionInfo', 'qDimensions'],\n  ['qMeasureInfo', 'qMeasures'],\n  ['qAttrDimInfo', 'qAttributeDimensions'],\n  ['qAttrExprInfo', 'qAttributeExpressions']\n];\n\nconst DIM_RX = /\\/qDimensionInfo(?:\\/(\\d+))?/;\nconst M_RX = /\\/qMeasureInfo\\/(\\d+)/;\nconst ATTR_DIM_RX = /\\/qAttrDimInfo\\/(\\d+)(?:\\/(\\d+))?/;\nconst ATTR_EXPR_RX = /\\/qAttrExprInfo\\/(\\d+)/;\nconst HC_RX = /\\/?qHyperCube/;\nconst TD_RX = /\\/?qTreeData/;\n\nconst SHORTEN_HC = path => `${path.substr(0, path.indexOf('/qHyperCubeDef') + 14)}`; // 14 = length of '/qHyperCubeDef'\nconst SHORTEN_TD = path => `${path.substr(0, path.indexOf('/qTreeDataDef') + 13)}`; // 13 = length of '/qTreeDataDef'\n\nexport function extractFieldFromId(id, layout) {\n  let path = id;\n  let dimensionIdx = -1;\n  let measureIdx = -1;\n  let pathToCube = '';\n  let shortenizer = p => p;\n  if (HC_RX.test(id)) {\n    pathToCube = `${path.substr(0, path.indexOf('qHyperCube') + 10)}`; // 10 = length of 'qHyperCube'\n    shortenizer = SHORTEN_HC;\n  } else if (TD_RX.test(id)) {\n    pathToCube = `${path.substr(0, path.indexOf('qTreeData') + 9)}`; // 9 = length of 'qTreeData'\n    shortenizer = SHORTEN_TD;\n  }\n\n  let shortenPath = true;\n\n  if (DIM_RX.test(id)) {\n    dimensionIdx = +DIM_RX.exec(id)[1];\n  }\n\n  if (M_RX.test(id)) {\n    measureIdx = +M_RX.exec(id)[1];\n  }\n\n  if (ATTR_DIM_RX.test(id)) {\n    measureIdx = -1;\n    dimensionIdx = 0;\n    const attrCol = +ATTR_DIM_RX.exec(path)[2];\n    if (!isNaN(attrCol)) {\n      dimensionIdx = attrCol;\n      path = path.replace(/\\/\\d+$/, '');\n    }\n    shortenPath = false;\n  }\n\n  if (ATTR_EXPR_RX.test(id)) {\n    // depends on number of measures + number of attr expressions\n    // in dimensions and measures before this one\n    const offset = measureIdx;\n    if (layout) {\n      measureIdx = 0;\n      const hc = resolve(pathToCube, layout);\n\n      // offset by number of measures\n      measureIdx += (hc.qMeasureInfo || []).length;\n\n      // offset by total number of attr expr in dimensions\n      // (assuming attr expr in dimensions are ordered first)\n      if (dimensionIdx > -1) {\n        measureIdx = hc.qDimensionInfo\n          .slice(0, dimensionIdx)\n          .reduce((v, dim) => v + dim.qAttrExprInfo.length, measureIdx);\n        dimensionIdx = -1;\n      } else {\n        measureIdx = hc.qDimensionInfo.reduce((v, dim) => v + dim.qAttrExprInfo.length, measureIdx);\n        // offset by total number of attr expr in measures before 'index'\n        measureIdx = hc.qMeasureInfo\n          .slice(0, offset)\n          .reduce((v, meas) => v + meas.qAttrExprInfo.length, measureIdx);\n      }\n\n      // offset by the actual column value for the attribute expression itself\n      measureIdx += +ATTR_EXPR_RX.exec(path)[1];\n    } else if (dimensionIdx > -1) {\n      dimensionIdx = -1;\n      measureIdx = +ATTR_EXPR_RX.exec(path)[1];\n    } else {\n      measureIdx += +ATTR_EXPR_RX.exec(path)[1] + 1;\n    }\n  }\n\n  LAYOUT_TO_PROP.forEach(([v, prop]) => {\n    path = path.replace(v, prop);\n  });\n\n  if (shortenPath) {\n    path = shortenizer(path);\n  }\n\n  if (path && path[0] !== '/') {\n    path = `/${path}`;\n  }\n\n  return {\n    measureIdx,\n    dimensionIdx,\n    path\n  };\n}\n\n/**\n * Helper method to generate suitable QIX selection methods and parameters based on a brush instance.\n * @alias brush\n * @memberof picasso.q\n * @param {brush} brush A brush instance\n * @param {object} [opts]\n * @param {boolean} [opts.byCells=false] Whether to prefer selection by row index.\n * @param {string} [opts.primarySource] Field source to extract row indices from. If not specified, indices from first source are used.\n * @param {object} [layout] QIX data layout. Needed only when brushing on attribute expressions, to be able to calculate the measure index.\n * @return {object[]} An array of relevant selections\n */\nexport default function qBrush(brush, opts = {}, layout) {\n  const byCells = opts.byCells;\n  const primarySource = opts.primarySource;\n  const selections = [];\n  const methods = {};\n  const isActive = brush.isActive();\n  let hasValues = false;\n  brush.brushes().forEach((b) => {\n    const info = extractFieldFromId(b.id, layout);\n    if (b.type === 'range' && info.measureIdx > -1 && info.dimensionIdx > -1) {\n      const ranges = b.brush.ranges();\n      if (ranges.length) {\n        hasValues = true;\n        if (!methods.multiRangeSelectTreeDataValues) {\n          methods.multiRangeSelectTreeDataValues = {\n            path: info.path,\n            ranges: []\n          };\n        }\n        ranges.forEach(range => methods.multiRangeSelectTreeDataValues.ranges.push({\n          qMeasureIx: info.measureIdx,\n          qDimensionIx: info.dimensionIdx,\n          qRange: {\n            qMin: range.min,\n            qMax: range.max,\n            qMinInclEq: true,\n            qMaxInclEq: true\n          }\n        }));\n      }\n    } else {\n      if (b.type === 'range' && info.measureIdx > -1) {\n        const ranges = b.brush.ranges();\n        if (ranges.length) {\n          hasValues = true;\n          if (!methods.rangeSelectHyperCubeValues) {\n            methods.rangeSelectHyperCubeValues = {\n              path: info.path,\n              ranges: []\n            };\n          }\n          ranges.forEach(range => methods.rangeSelectHyperCubeValues.ranges.push({\n            qMeasureIx: info.measureIdx,\n            qRange: {\n              qMin: range.min,\n              qMax: range.max,\n              qMinInclEq: true,\n              qMaxInclEq: true\n            }\n          }));\n        }\n      }\n      if (b.type === 'range' && info.dimensionIdx > -1) {\n        const ranges = b.brush.ranges();\n        if (ranges.length) {\n          hasValues = true;\n          if (!methods.selectHyperCubeContinuousRange) {\n            methods.selectHyperCubeContinuousRange = {\n              path: info.path,\n              ranges: []\n            };\n          }\n          ranges.forEach(range => methods.selectHyperCubeContinuousRange.ranges.push({\n            qDimIx: info.dimensionIdx,\n            qRange: {\n              qMin: range.min,\n              qMax: range.max,\n              qMinInclEq: true,\n              qMaxInclEq: false\n            }\n          }));\n        }\n      }\n      if (b.type === 'value' && info.dimensionIdx > -1) {\n        if (byCells) {\n          if (!methods.selectHyperCubeCells) {\n            methods.selectHyperCubeCells = {\n              path: info.path,\n              cols: []\n            };\n          }\n\n          methods.selectHyperCubeCells.cols.push(info.dimensionIdx);\n          if (b.id === primarySource || (!primarySource && !methods.selectHyperCubeCells.values)) {\n            methods.selectHyperCubeCells.values = b.brush.values()\n              .map(s => +s)\n              .filter(v => !isNaN(v));\n            hasValues = !!methods.selectHyperCubeCells.values.length;\n          }\n        } else {\n          const values = b.brush.values().map(s => +s).filter(v => !isNaN(v));\n          hasValues = !!values.length;\n          selections.push({\n            params: [info.path, info.dimensionIdx, values, false],\n            method: 'selectHyperCubeValues'\n          });\n        }\n      }\n    }\n  });\n\n  if (!hasValues && isActive) {\n    return [{\n      method: 'resetMadeSelections',\n      params: []\n    }];\n  }\n\n  if (methods.rangeSelectHyperCubeValues) {\n    selections.push({\n      method: 'rangeSelectHyperCubeValues',\n      params: [methods.rangeSelectHyperCubeValues.path, methods.rangeSelectHyperCubeValues.ranges, [], true]\n    });\n  }\n\n  if (methods.selectHyperCubeContinuousRange) {\n    selections.push({\n      method: 'selectHyperCubeContinuousRange',\n      params: [methods.selectHyperCubeContinuousRange.path, methods.selectHyperCubeContinuousRange.ranges]\n    });\n  }\n\n  if (methods.selectHyperCubeCells) {\n    selections.push({\n      method: 'selectHyperCubeCells',\n      params: [\n        methods.selectHyperCubeCells.path,\n        methods.selectHyperCubeCells.values,\n        methods.selectHyperCubeCells.cols\n      ]\n    });\n  }\n\n  if (methods.multiRangeSelectTreeDataValues) {\n    selections.push({\n      method: 'multiRangeSelectTreeDataValues',\n      params: [methods.multiRangeSelectTreeDataValues.path, methods.multiRangeSelectTreeDataValues.ranges]\n    });\n  }\n\n  return selections;\n}\n","import data from './data/dataset';\nimport qBrushHelper from './brush/q-brush';\nimport numberFormat from './formatter/numberFormat';\nimport timeFormat from './formatter/timeFormat';\n\nexport default function initialize(picasso) {\n  data.util = picasso.data('matrix').util;\n  picasso.data('q', data);\n  picasso.formatter('q-number', numberFormat);\n  picasso.formatter('q-time', timeFormat);\n}\n\ninitialize.qBrushHelper = qBrushHelper; // deprecated\ninitialize.selections = qBrushHelper;\n"],"sourceRoot":""}